# Langages de programmation au typage statique

Le présent repo s'addresse aux développeurs qui n'ont connu que des langages au typage dynamique comme **JavaScript** ou **Python**. L'objectif est de vous introduire aux langages dont le système de typage est statique. Nous illustrerons les concepts que nous aborderons à l'aide de 3 langages de programmation : **JavaScript**, **C#** et **Rust**. 

- [Introduction](#introduction)
- [Typage statique](#typage-statique)
    - [Fonctions et classes](#fonctions-et-classes)
    - [Programmation générique](#programmation-générique)
    - [Polymorphisme](#polymorphisme)
        - [Polymorphisme à base d'héritage](#polymorphisme-à-base-dhéritage)
        - [Polymorphisme à base de composition](#polymorphisme-à-base-de-composition)
    - [TypeScript](#typescript)
- [Conclusion](#conclusion)

## Introduction

Commençons en rappelant une évidence : Dans un système de typage dynamique, une variable peut changer de type à n'importe quel moment. Par exemple, vous pouvez assigner un nombre à une variable, puis changer sa valeur avec une chaine de caractère :

```js
//  JavaScript
let variable = 1;
variable = "text";
```

Ce simple script ne génère aucune erreur. En revanche, si nous faisons la même chose dans un système de typage statique, nous rencontrons une erreur :

```c#
//  C#
int variable = 1;
variable = "text";
//  error CS0029: Impossible de convertir implicitement le type 'string' en 'int'
```

Profitons de la simplicité de cet exemple pour remarquer que, dans un système de typage statique, nous devons déclarer le type que nous voulons associer à une variable. En l'occurence, `variable` est de type `int`, un nombre entier. Afin d'assigner la chaine de caractère `"text"` à une variable, nous sommes obligé d'en déclarer une autre :

```c#
//  C#
int variable1 = 1;
string variable2 = "text";
```

La syntaxe `type <name>` pour déclarer une variable est considérée désuète aujourd'hui. Vous la trouverez en général dans des langages qui ont au moins 20 ans comme **C++**, **C#** ou **Java**. Les langages modernes comme **Kotlin** et **Rust** utilisent une syntaxe de la forme `keyword <name> : type` :

```rust
//  Rust
let variable : i32 = 1;
```

Cette syntaxe ne devrait pas vous éloigner de vos habitudes si vous êtes un développeur **JavaScript**. Cependant, nous pouvons faire encore mieux. Ces langages modernes sont capables d'inférer le type d'une variable en fonction de la valeur que nous lui assignons. Ainsi, nous pouvons simplifier le code précédent et laisser le langage assigner le bon type à la variable :

```rust
//  Rust
let variable = 1;
```

Avec un tel niveau d'abstraction, il ne reste plus aucune différence entre la déclaration et l'assignation d'une variable dans un système de typage dynamique ou statique. Cependant, ce n'est pas toujours vrai. Il existe des situations où le contexte ne permet pas au langage d'inférer le type d'une variable. L'exemple précédent est simple et sans équivoque.

Pour conclure cette introduction, sachez que l'abstraction que nous venons de décrire parait tellement évident que les plus vieux langages comme **C#** et **Java** l'ont adopté. Ces deux langages ont opté pour le mot clef `var`. Malheureusement, quand le langage ne peut pas inférer le type d'une variable, nous devons utiliser la vieille syntaxe.

Penchons nous maintenant sur les spécificités des systèmes de typage statique afin d'en tirer les avantages et les inconvénients.

## Typage statique

Dans l'[introduction](#introduction), nous avons vu comment un système de typage statique impact la déclaration et l'assignation de variables. Toutefois, cet exemple basique ne nous permet pas d'explorer les forces et les faiblesses de ces systèmes. Regardons comment déclarer des fonctions et des classes afin d'explorer les spécificités du typage statique. 

### Fonctions et classes
---

Commençons par regarder comment construire une fonction qui additionne 2 nombres entiers en **JavaScript** et en **Rust**.

- [javascript/somme](./javascript/somme.js)
- [rust/somme](./rust/techtalk/src/examples/somme.rs)

Dans l'exemple écrit en **Rust**, le type des paramètres `a` et `b`, ainsi que le type de retour de la fonction `somme()`, sont précisés. Contrairement aux variables, ces précisions sont obligatoires pour une fonction car le langage ne peut pas deviner son usage puisque nous ne pouvons pas appeler une fonction au même moment que nous la déclarons (exception faite des fonctions anonymes que nous n'aborderons pas). De plus, dans cet exemple, chaque paramètre d'entrée et de sortie de la fonction `somme()` sont de même type (`i32`), mais ils auraient pu avoir des types différents si c'était nécessaire.

Une fois que nous avons attribué un type à chaque paramètre de la fonction (y compris le retour), nous somme contraint de respecter son typage lorsque nous l'appelons. Ce n'est pas vrai dans un système de typage dynamique puisqu'il n'y a aucune contrainte sur les paramètres d'une fonction. Par exemple, bien que la fonction `somme()` écrite en **JavaScript** soit prévue pour additionner des nombres, rien ne nous empêche de l'[utiliser](/javascript/main.mjs) pour concaténer deux chaines de caractères :

```js
//  JS
somme("une chaine", "de caractères")
```

En revanche, si nous essayons d'appeler la fonction `somme()` écrite en **Rust** sur ces deux mêmes chaines de caractères, nous obtenons l'erreur suivante :

```sh
error[E0308]: arguments to this function are incorrect
```

Tout ce que nous venons de dire est également vrai pour une classe, ses attributs et ses méthodes. Pour illustrer, définissons une classe simple, en **C#**, qui possède deux attributs, `name` et `valid` :

- [dotnet/Exemple](/dotnet/techtalk/TechTalk/Exemple.cs)

Lorsque nous déclarons une classe, nous devons préciser le type de chacun de ses attributs. En conséquence, nous devons respecter le type de ces attributs lorsque nous instancions la classe `Exemple`. Le code suivant ne génère une erreur :

```c#
//  C#
var exemple = new Exemple(0, false);
//  Argument 1: cannot convert from 'int' to 'string'
```

Parlons à présent des avantages et des inconvénients des système de typage statique. Tout d'abord, comparé à un système de typage dynamique, le typage statique est contraignant comme nous l'avons vu avec la fonction `somme()`. En contrepartie, cette contrainte prévient un ensemble d'erreurs qui, en **JavaScript**, se manifestent par l'apparition de valeurs `undefined` un peu partout. A titre d'exemple, cette erreur se produit quand nous essayons d'utiliser la méthode `map()` sur une variable de type `String`. Les systèmes de typage statique préviennent ce genre d'erreur. Toutefois, ces systèmes ne sont pas infaillibles. Ils ne peuvent pas prévenir une erreur de type si une valeur n'est connue qu'au moment de l'exécution, comme lorsqu'un client communique avec un serveur.

Un autre avantage des systèmes de typage statique prend place dans les IDE. Puisque que nous pouvons connaitre le type de chaque variable ou les types attendus dans une fonction à chaque instant, notre IDE le peut aussi. En conséquence, les IDE utilisent ces informations pour proposer de l'autocomplétion de code et de la détection d'erreur. L'outil qui permet de faire ça s'appelle **IntelliSense**.

Revenons une dernière fois sur la contrainte de notre fonction `somme()` écrite en **Rust** avec un questionnement légitime : **Que devons-nous faire si nous voulons que notre fonction `somme()` accepte des nombres réels (à virgule) ou des chaines de caractères en paramètre  comme en **JavaScript** ? Devons-vous écrire une autre version de cette fonction pour chaque type existant ?** A une époque pas si lointaine, c'est effectivement ce que nous aurions dû faire. Heureusement, des outils permettent de reproduire la flexibilité du typage dynamique au sein des systèmes de typage statique mais avec plus de contrôle : l'**héritage**, **polymorphisme** et la **programmation générique**. Chacun de ces concepts à des applications différentes et complémentaires qui ne se cantonnent pas au typage. De plus, ces concepts sont intimement liés.

Nous illustrerons toutes ces approches en **C#** car ce langage incorpore aussi bien les vieux outils qui permettent de mettre en place ces stratégies que les nouveaux.

### Héritage et polymorphisme
---

L'héritage et le polymorphisme sont des concepts intimement liés, nous les traitons donc simultanément. Si vous êtes familier de la programmation orienté objet, vous connaissez déjà ces deux concepts, mais un rappel ne fera de mal à personne.

#### Rappels
---

L'**héritage** est le mécanisme par lequel une classe `B` copie les attributs, les méthodes et les implémentations de ces méthodes d'une autre classe `A`. Dit de manière plus concise, une classe hérite d'une autre quand elle reçoit son implémentation et uniquement son implémentation. L'héritage ne doit pas être confondu avec le fait de copier les valeurs d'une instance vers une autre. Une classe héritière `B` peut avoir des attributs et des méthodes que la classe parent `A` ne possède pas. La réciproque n'est pas vraie.

- [dotnet/Heritage](/dotnet/techtalk/TechTalk/Heritage.cs)

De son côté, le **polymorphisme** est le mécanisme par lequel deux classes `B` et `C` partagent une ou plusieurs méthodes (uniquement des méthodes) mais ces méthodes ont des implémentations différentes. La manière historique de procéder est d'utiliser une troisième classe `A` pour stocker les méthodes communes, de faire hériter ces méthodes aux deux autres classes et de modifier les implémentations de ces méthodes. Une approche plus moderne, toujours basée sur l'héritage, consiste à utiliser des **classes abstraites** qui sont des classes qui

1) Ne peuvent pas être instanciées.
2) Dont les méthodes ne nécessitent pas une implémentation.

- [dotnet/Polymorphisme](/dotnet/techtalk/TechTalk/Polymorphisme.cs)

En l'absence de classe abstraite, si une classe parent `A` n'a pas vocation à être instanciée, l'implémentation de toutes ses méthodes consiste à générer une erreur.

Pour conclure ce rappel, regardons comment faire du polymorphisme sans héritage. Sans héritage, la seule façon de faire est la composition de classes. Pour mettre en place cette stratégie, nous n'avons besoin que de 2 classes `B` et `C` qui partagent au moins une méthode, même si les implémentations sont différentes. Pour des raisons techniques, la compositions de classe utilise également une classe intermédiaire `A` pour stocker les méthodes communes. En effet, utiliser cette classe intermédiaire `A` permet au langage de vérifier plus facilement si deux classes `B` et `C` partagent un ensemble de méthodes.

En pratique, la composition diffère de l'héritage par sa plus grande modularité. En effet, plutôt que de réfléchir à une hiérarchie de classes qui va d'une entité globale vers une entité précise comme dans [les exemples](/dotnet/techtalk/TechTalk/Polymorphisme.cs) donné précédemment, l'idée est de définir des comportements que entités concrètes peuvent partager indépendément de leur parenté. Un outil appelé **interface** permet de mettre la composition de classes simplement. Les interfaces ressemblent aux classes abstraites :

1) Une interface ne peut pas être instanciée.
2) Les méthodes d'une interface ne nécessitent pas d'implémentation. *En théorie, les méthodes d'une interface ne peuvent pas avoir d'implémentation par défaut. En pratique, ça dépend du langage.*
3) Une interface ne peut pas avoir d'attributs. *Egalement en théorie.*

*En **C#**, les interfaces et les classes abstraites sont interchangeables sauf sur un point : Une classe `B` ne peut **hériter** que d'une seule classe `A`, y compris si c'est une classe abstraite. En revanche, cette même classe `B` peut **implémenter** plusieurs interfaces.*

- [dotnet/Composition](/dotnet/techtalk/TechTalk/Composition.cs)

Dans ce dernier exemple, nous avons volontairement mélangé les deux approches car l'héritage et la composition ne sont pas mutuellement excluantes.

#### Typage statique et polymorphisme

Si vous connaissiez tous les concepts que nous venons de passer en revue, vous savez qu'ils ne sont absolument pas exclusifs aux langages à système de typage statique. Toutefois, nous avons fait ces rappels pour répondre à un objectif que nous nous sommes fixé : **Reproduire la flexibilité du typage dynamique au sein des systèmes de typage statique.**

Pour accomplir cet objectif, il nous suffit de prendre conscience de deux choses :

1) A chaque fois que nous déclarons une classe/interface, nous définissons également un type "personnalisé".
2) Lorsqu'une classe `B` hérite d'une classe `A` ou implémente une interface `I`, elle reçoit aussi le type de la classe/l'interface. *Les types s'accumulent, la classe `B` conserve donc son type.*

Nous pouvons donc manipuler un ensemble d'objets de types différents en utilisant le type d'une classe parent ou une interface commune.

- [dotnet/Program](/dotnet/techtalk/TechTalk/Program.cs)

Avec cette première approche, si nous construisons un ensemble de classes et d'interfaces dont les relations sont un minimum pertinentes, nous pouvons déjà passer outre les limitations du système de typage statique. Cependant, nous avons abordé l'existence d'une autre approche : **la programmation générique**.

### Programmation générique
---

La programmation générique, parfois aussi appelée polymorphisme de type, est une autre approche utilisée pour reproduire la flexibilité des système de typage dynamique. La raison pour laquelle cette stratégie existe est importante :

- Bien que le polymorphisme par héritage que nous venons de voir permet de reproduire la flexibilité du typage dynamique, il reproduit également les comportements source d'erreurs : **la mutabilité de type**.

En effet, une conséquence du polymorphisme par héritage est que des classes héritières `B` et `C` d'une même classe `A` sont interchangeables. Nous avons même vu un exemple où nous déclarons une variable de type `Animal` à laquelle nous assignons un `Canard` avant de changer la valeur par un `Chat`. 

C'est exactement la problématique à laquelle répond la programmation générique. Elle permet cette flexibilité, c'est-à-dire de pouvoir utiliser un `Canard` et un `Chat` avec une même fonction, méthode ou boucle, tout en assurant l'immutabilité du type de chaque instance.

Plongeons nous directement dans un exemple en reprenant la fonction `somme()` de l'[introduction](#introduction) que nous adapterons en une méthode statique puisque les fonctions n'existent pas en **C#** :

- [dotnet/Somme](./dotnet/techtalk/TechTalk/Somme.cs)

Dans cet exemple, nous définissons un **type générique** `T`. Vous pouvez interpréter ce générique comme une "variable de type", dont le nom est "T", que nous passons à la méthode `Somme<T>()`. Cette méthode est dont appelée méthode générique (même chose pour une classe ou une fonction) de paramètre `T`. Ce paramètre `T` peut être utilisé comme un type anonyme, abstrait (générique), dans le contexte de la méthode.

*Un type générique peut avoir n'importe quel nom, comme une variable. A la place de `T`, nous aurions pu mettre `cupOfTea` sans que cela pose problème. Par contre, il existe des conventions de nommage. Par exemple, la lettre `N` est recommandée pour les types numériques. La lettre `T` est le choix par défaut et renvoit simplement à "type".*

Revenons à la déclation de notre méthode générique et attardons nous un peu plus sur le rôle de chaque `T` : 

```c#
//  C#
public static T Somme<T>(T a, T b) where T : INumber<T>
              1       2  3    4          5           6
```

Dans toutes les apparitions de `T`, la plus importante est la numéro 2. La syntaxe `<T>` signifie que nous déclarons le type générique `T` comme "paramètre de type" de la méthode `Somme<T>()`, de manière analogue que nous déclarons les paramètres (de valeur) `a` et `b`. Les `T` numéros 1, 3 et 4 prennent simplement la place d'un type concret.

Avant de parler de la dernière partie de la déclation de notre méthode `Somme()`, prenons le temps de remarquer quelque chose de trivial. Puisque `T` peut incarner, a priori, n'importe quel type, nous pourrions conclure hativement que nous avons inventé le typage dynamique dans un système de typage statique. C'est évidemment faux. Afin d'expliquer pourquoi, ajoutez une ligne de code dans la [méthode `Somme<T>()`](./dotnet/techtalk/TechTalk/SommeAvecGenerique.cs) qui modifie la valeur de `a` par une chaine de caractère, ou même un nombre. Vous obtiendrez l'erreur :

```sh
Cannot implicitly convert type 'string' to 'T'
```

Vous reconnaitrez peut-être l'erreurr que nous avons rencontré dans l'introduction. Le type générique `T` n'est pas définit explicitement mais se comporte comme un type concret. Ainsi, il n'est pas possible de changer le type de `a` et de `b`.

Pour ressentir toute la puissance des types génériques, regardons ce qu'il se passe quand nous [appelons cette méthode](/dotnet/techtalk/TechTalk/Program.cs). En opposition à l'approche sans générique, vous remarquerez qu'on nous utilisons bien la même fonction à 2 reprises. Dans cet exemple, nous exploitons la capacité du compilateur à inférer le type concret de `T`. Si ce n'était pas possible, nous devrions le préciser :

```c#
//  C#
int result1 = SommeAvecGenerique.Somme<int>(2, 3);
double result2 = SommeAvecGenerique.Somme<double>(0.1, 0.2);
```

C'est tout de suite plus verbeux ! Heureusement, l'inférence se fait à deux niveau :

- Lors de la déclaration de `result1` et `result2`. Le type de ces variables est déduit du type concret de la méthode générique `Somme<T>`.
- Lors de l'appel de la méthode `Somme<T>`. Le type concret de `T` est déduit des valeurs passées en paramètres de la méthode.

Toutes ces couches d'abstraction simplifient le travail des développeurs.

Du point de vue de l'ordinateur, le compilateur défini une nouvelle méthode `Somme()` pour chaque type concret utilisés dans le programme. Ce procédé s'appelle monomorphization et il nous épargne de devoir écrire une méthode pour chaque cas de figure comme dans le [premier exemple](/dotnet/techtalk/TechTalk/Somme.cs).

Revenons maintenant à la dernière partie de la déclaration de la méthode `Somme<T>()` :

```c#
//  C#
where T : INumber<T>
```

Cette dernière partie sert à restreindre les types concrets que peut prendre le générique `T` à l'ensemble des classes qui implémentent l'interface `INumber`. Si vous n'êtes pas familier des concepts d'interface et d'implémentation, nous reviendrons dessus plus tard. En attendant, voyez une interface comme une classe qui n'aurait que des méthodes vides et une implémentation comme le fait d'hériter des méthodes de cette interface tout en les remplissant.

Une dernière notion importante avec les types génériques est leur encapsulation. Imaginez que vous ayez besoin de construire une classe [`Arithmetic<T>`](/dotnet/techtalk/TechTalk/Arithmetique.cs) pour encapsuler et manipuler des nombres. Plutôt que de créer une classe pour chaque type numérique, vous pouvez définir une classe générique de la même façon que nous l'avons fait avec la méthode `Somme<T>()`. Toutefois, contrairement au cas de la méthode, le compilateur de `C#` n'est pas capable d'inférer le type concret de `T` à partir des valeurs passées dans le constructeur, il faut donc le préciser au moment de l'[instanciation](/dotnet/techtalk/TechTalk/Program.cs). D'autres langages en sont capable. a besoin que vous lui donnez un type concret lors de l'instanciation de la classe `Arithmetic<T>`.

Par soucis de simplicité, nous n'avons traité que des exemples avec un générique. Bien entendu, nous pouvons définir autant de type générique que nous en avons besoin et les mélanger avec des types concrets :

```c#
//  C#
class Example
{
    public static void ExampleMethod<T, U, V>(T arg1, U arg2, V arg3, int arg4, string arg5)
    {
        // code
    }
}
```

Chaque type générique peut être restreint par le mot clef `where`, et ces restrictions peuvent être différentes pour `T`, `U` et `V`. L'implémentation des types génériques varie d'un langage à l'autre. En général, les règles et la syntaxe tendent à se simplifier et offrir plus de confort au développeur avec les langages plus récents. Si le sujet vous intéresse, vous pouvez comparer les implémentations des génériques en **Java** et en **C#**.

Maintenant que nous avons fait le tour du sujet des génériques et expliqué comment ils permettent d'épargner énormément de répétabilité dans le code, posons nous une dernière question. **Comment fait-on si nous avons besoin que le type d'une variable change pendant l'exécution ?** La réponse courte est que vous ne pouvez pas, pas directement. En général, la librarie standard d'un langage intègre des méthodes pour convertir le type de la valeur d'une variable que vous devrez bien entendu stocker dans une autre variables. Par exemple :

```c#
//  C#
int number = 0;
string numberString = number.ToString();
```

Une stratégie qui doit vous sembler familière. Toutefois, cette approche n'est pas possible pour les types définis par le développeur, sachant que chaque classe défini un nouveau type. Une approche commune qui s'intègre bien avec la programmation générique s'appelle **polymorphisme**. Nous exploitons déjà ses propriétés quand nous limitons le type de `T` à l'interface `INumber` dans les exemples précédents.

### Polymorphisme
---

La notion de polymorphisme ne vous est peut-être pas étrangère si vous avez une certaine expérience en programmation orientée objet puisque ce concept n'est pas exclusif aux langages à système de typage statique. Le polymorphisme peut être défini simplement comme le fait que deux classes partagent une même méthode dont les implémentations diffèrent.

Dans un langage au typage dynamique comme **JavaScript**, le polymorphisme n'a pas vraiment d'application qui lui est propre puisque deux objets peuvent être utilisés de manière indifférenciée, au risque de rencontrer un `undefined`. En revanche, ce concept est fondamental dans les langages orientés objet au typage statique puisqu'il permet simuler un typage dynamique dans une version plus contrôlée.

Pour produire cet effet, deux stratégies sont utilisées : l'**héritage** et la **composition**. Attention, l'héritage et la composition sont des concepts à part entière et ne réduisent pas au polymorphisme. En revanche, ces deux concepts peuvent être utilisés pour faire du polymorphisme.

#### Polymorphisme à base d'héritage 
---

Le polymorphisme à base d'héritage est l'exemple que vous trouverez le plus souvent dans la littérature. Pour l'accomplir, nous avons besoin d'une classe générale et d'au moins deux classes spécialisées.

- [dotnet/PolymorphismeAvecHeritage](/dotnet/techtalk/TechTalk/PolymorphismeAvecHeritage.cs)

Nous n'entrerons pas dans les détails de cette implémentation car notre but n'est pas de d'apprendre **C#**. Votre attention doit se porter uniquement sur les deux classes `Canard1` et `Chat1` qui héritent des attributs et des méthodes de la classe `Animal`. Dans cet exemple, la classe `Animal` n'a pas de valeur par défaut pour son attribut `species` et n'a pas d'implémentation par défaut pour sa méthode `Cri`, mais ça aurait pu être le cas.

Le polymorphisme, dans cet exemple, est basé sur l'héritage en ce sens que les classes héritières `Canard1` et `Chat1` **sont** également des `Animal`(-aux) car elles en ont toutes les caractéristiques (attributs) et tous les comportements (méthodes), mais surtout parce qu'elles héritent également du type `Animal` associé à la classe éponyme. Bien entendu, `Canard1` et `Chat1` peuvent posséder des attributs et des méthodes qui leurs sont propres comme des ailes, une queue, la capacité de voler ou la capacité de voir dans le l'obscurité.

Après toutes ces explications, vous vous demandez sans doute ce que tout celà à avoir avec le typage statique. Nous y arrivons. Admettons que nous développions une application pour détenteurs d'animaux de compagnie. Rien ne nous dit que les utilisateurs de notre application auront tous exactement un animal de compagnie, nous devons donc implémenter une liste. **Problème : comment créer une liste qui peut accueillir des animaux d'espèces différentes ?** 

Pour résoudre ce problème, nous pouvons nous passer de nos classes `Canard1` et `Chat1` (et donc du polymorphisme), et donner la responsabilité de différencier chaque espèce d'animal à la classe générale `Animal`. Vous imaginez bien que cette approche est fastidieuse. En procédant ainsi, nous devrions préciser à chaque fois si oui ou non un animal à une queue, si oui ou non il peut voler, ... La quantité d'attributs et de méthodes serait ingérable.

Plutôt que de nous compliquer la vie, [utilisons le système d'héritage à notre avantage](/dotnet/techtalk/TechTalk/Program.cs). Plus tôt dans le texte, nous avons évoqué le fait que chaque classe déclarée par le développeur déclare également un type. Autrement dit, chaque instance de la classe `Animal` est une variable de type `Animal`. Vous vous en doutez, quand une classe hérite d'une autre, elle hérite aussi de son type. En conséquence, les classes `Canard1` et `Chat1` sont respectivement de type `Canard1` et `Chat1` **et** de type `Animal`. La réciproque n'est pas vraie (un animal n'est pas un canard). Nous pouvons pousser la logique un cran plus loin et déclarer une variable de type `Animal` pour y assigner des instances de `Canard1` et de `Chat1` sans que celà ne pose de problème.

Voilà, nous avons reproduit une forme de typage dynamique contrôlé dans un système de typage statique ! Toutefois, nous avons mentionné une autre façon de faire. Nous ne nous attarderons pas sur les raisons historiques qui justifient l'existence d'une seconde approche. Nous nous contenterons d'un simple exemple fictif pour illustrer un problème induit par cette première approche :

```c#
//  C#
var animaux = new List<Animal>(new Canard(), new Chat(), new Moustique());
foreach (Animal animal in animaux)
{
    animal.cri()
    animal.voler();
}
```

Comme vous le devinez, le code ci-dessus génère une erreur car la classe `Chat` ne possède pas de méthode `voler()`. Rien ne nous empêche d'insérer une classe `AnimauxVolants` dans la chaine d'héritage afin de séparer le `Canard` et le `Moustique` du `Chat`. Toutefois, cette approche peut causer d'autres problèmes propres à l'héritage que nous n'aborderons pas. C'est pour ça qu'il existe une seconde approche se reposant sur l'idée d'**avoir** des comportements en commun plutôt que d'**être** une entité plus globale. Cependant, avant de nous pencher sur cette seconde approche, explorons un exemple supplémentaire qui va nous permettre de faire le lien avec les génériques :

- [dotnet/PolymorphismeAvecHeritageEtGenerique](/dotnet/techtalk/TechTalk/PolymorphismeAvecHeritageEtGenerique.cs)

Dans cet exemple, nous construisons une méthode statique qui nous permet de faire aboyer un `Chien` indépendamment de sa race (`Golden_Retriever` ou `Rottweiler`), mais nous contraignons le type de l'paramètre `chien` à l'aide d'un générique :

```c#
//  C#
class Trick
{
    public static void Aboyer<T>(T chien) where T : Chien
    {
        chien.Cri();
    }
}
```

Notez que, dans cet exemple, il serait tout à fait équivalent de définir la méthode `Aboyer<T>()` comme suit :

```c#
public static void Aboyer(Chien chien)
```

Toutefois, vous rencontrerez des situations où du polymorphisme avec et sans générique ne sont pas interchangeables.

#### Polymorphisme à base de composition
---

La seconde stratégie pour mettre en place du polymorphisme repose sur l'idée de composer une entité concrète à partir de comportements sans se soucier de ses caractéristiques. Afin de rendre cette approche plus simple, la majorité des langages de programmation orientée objet implémente une structure appelée **interface** (parfois trait).

Une interface diffère d'une classe (abstraite ou non) sur trois points :

- Une interface ne possède que des méthodes, aucun attribut.
- Aucune des méthodes d'une interface ne possède d'implémentation.
- Une interface ne peut pas être instanciée

*En pratique, les deux premières règles ne sont pas toujours vraies. Beaucoup de langages implémentent une structure **classe abstraite** qui ne respecte que la dernière règle contrairement aux interfaces. En **C#**, bien que les interfaces et les classes abstraites existent, cette distinction ne se fait que par convention. En revanche, une classe ne peut hériter que d'une seule classe (abstraite) mais peut hériter de plusieurs interfaces.*

Par essence, les interfaces s'inscrivent sans difficulté dans le paragidme de composition bien qu'elle s'intègrent également dans le paradigme d'héritage. D'ailleurs, seul un mot clef distingue le procédé qui consiste à transférer le contenu d'une classe ou d'une interface vers une autre classe dans la plus part des langages, quand ce mot clef n'est pas le même pour les deux. 

Regardons comment construire notre exemple d'animaux avec des interfaces :

- [dotnet/PolymorphismeAvecComposition](/dotnet/techtalk/TechTalk/PolymorphismeAvecComposition.cs)

Avec cette approche, la seule chose qui lie `Canard2` et `Chat2` est leur capacité à `Crier()`, ce qui permet de manipuler des animaux d'espèces différentes de façon plus intuitive. En effet, avec l'[approche précédente](#polymorphisme-à-base-dhéritage) vous devez savoir quels animaux sont capables de voler ou de crier avant de les manipuler au sein d'une même liste. Il est évident qu'un `Chat` ne peut pas voler, mais vous rencontrerez des situations où ce n'est pas aussi évident de deviner les comportements (méthodes) partagés par un ensemble de classes qui possèdent un parent commun.

En revanche, lorsque vous manipulez des classes qui partagent uniquement des comportements regroupés dans des interfaces, tout devient plus explicite pour vous comme pour le compilateur quand vous manipulez des objets de types différents :

```c#
var animauxAvecCri = new List<ICrier>(new Canard(), new Chat());
foreach (ICrier animalAvecCri in animauxAvecCri)
{
    animalAvecCri.Cri();
}
```

Cette stratégie s'intègre également plus intuitivement avec des types génériques que l'héritage. Nous ne nous atterderons pas sur un exemple puisque nous avons déjà vu comment utiliser l'interface numérique à la section dédiée à la [programmation générique](#programmation-générique).

Dorénavant, vous avez toutes les cartes en main pour adopter un système de typage statique. Bien entendu, vous devrez pratiquer un peu avant d'assimiler chaque concept, en particulier la programmation générique. Avant de conclure, penchons nous sur un langage de programmation construit par dessus **JavaScript** : **TypeScript**.

### TypeScript
---

Nous avons déjà exploreé beaucoup de choses jusqu'à présent. Plutôt que de rallonger la lecture inutilement, rendez-vous sur le site de TypeScript pour en apprendre plus.

- [TypeScript](https://www.typescriptlang.org/)

Sachez juste que **TypeScript** n'a pas vocation à être interprété par votre environnement d'exécution (Node, Deno, Bun, ...), bien que certains puissent le faire. Dans un projet classique, **TypeScript** est utilisé pour développer en profitant des avantages du système de typage statique pour vous éviter un certain nombre d'erreurs. Ensuite, vous pouvez "compiler" (transpiler pour être exact) le code vers du **JavaScript** exécutable partout, y compris dans un navigateur.

**TypeScript** s'intègre également très bien dans les frameworks **JavaScript** les plus connus comme **React**. De plus, nous citerons **Angular** en particulier qui est directement implémenté en **TypeScript**.

## Conclusion

# Langages de programmation au typage statique

- [Introduction](#introduction)
- [Typage statique](#typage-statique)
    - [Fonctions et classes](#fonctions-et-classes)
    - [Programmation générique](#programmation-générique)
    - [Polymorphisme](#polymorphisme)
        - [Polymorphisme à base d'héritage](#polymorphisme-à-base-dhéritage)
        - [Polymorphisme à base de composition](#polymorphisme-à-base-de-composition)
    - [TypeScript]()
- [Conclusion]()

## Introduction

Ce repo s'addresse aux développeurs qui n'ont connu que des langages au typage dynamique. Ici, nous nous intéresserons à **JavaScript**, mais il n'est pas le seul langage populaire à présenter cette caractéristique. Un exemple notable est **Python**. 

La spécificité d'un langage au typage dynamique est que le type d'une variable peut changer à n'importe quel moment. Ce concept peut vous paraître abstrait puisque, du point de vue d'un développeur **JavaScript**, le concept de type n'existe pas. Pour vous aider à comprendre de quoi il retourne, regardons comment une variable est déclarée dans des langages au typage dynamique et statique en commençant par **JavaScript** :

```js
//  JS
let variable = 1;
variable = "text";
```

Si nous affichions la valeur de `variable` dans le terminal, nous lirions :

```sh
text
```

En opposition, regardons le même code en **C#** :

```c#
//  C#
int variable = 1;
variable = "text";
```

Vous pouvez constater que la déclaration de `variable` contient le mot clef `int` plutôt que `let`. Celà signifie que `variable` est une variable qui ne peut contenir que des valeurs de type `int` (nombre entier). Si nous essayions d'afficher la valeur de `variable` comme à l'exemple précédent, nous n'y arriverions pas car le code ne compilarai pas :

```sh
error CS0029: Impossible de convertir implicitement le type 'string' en 'int'
```

*Faisons une brève digression pour souligner que **JavaScript** et **C#** ont une autre différence majeure que leur système de type : **JavaScript** est un langage interprêté tandis que **C#** est un langage compilé. Cette autre différence fondamentale a des implications tout aussi importante que le système de typage mais nous n'avons pas l'espace pour explorer le sujet ici !*

La syntaxe `type <name>` est considérée comme désuète aujourd'hui. Elle se retrouve principalement sur des langages qui ont au moins 20 ans comme **C++**, **C#** ou **Java**. Les langages modernes comme **Kotlin** et **Rust** utilisent une syntaxe de la forme `keyword <name> : type` :

```rust
//  Rust
let variable : i32 = 1;
```

Voilà une syntaxe qui ne vous bousculera pas trop de vos habitudes en **JavaScript** ! Histoire de vous éviter un peu plus le mal du pays, il se trouve que ces langages ont la capacité d'inférer le type d'une variable selon le contexte de son allocation. Dit plus simplement, il n'est pas toujours (ça dépend du contexte) nécessaire de préciser le type de la variable :

```rust
//  Rust
let variable = 1;
```

Cette approche semble tellement évidente que les plus vieux langages comme **C#** et **Java** ont également adopté cette syntaxe à un moment donné de leur histoire. En l'occurrence, les deux langages cités ont opté pour le mot clef `var`. Malheureusement, quand il n'est pas possible d'inférer le type d'une variable, il faut revenir à la vieille syntaxe, syntaxe qui est quand même moins élégante, vous me l'accorderez !

A ce stade, vous ne voyez sans doute pas l'intérêt du système de typage, c'est normal. C'est pour ça que nous allons explorer plus d'exemples afin de parler des bénéfices de ce système.

## Typage statique

Dans l'[introduction](#introduction), nous avons vu comment un système de typage statique impact la déclaration et l'allocation de variables. Toutefois, cet exemple est trop basique pour que nous puissions parler des avantages et des inconvénients d'un tel système.

Afin d'explorer les bienfaits du typage statique, penchons nous d'abord sur la construction de fonctions et de classes.

### Fonctions et classes

Commençons par regarder comment construire une fonction qui additionne 2 nombres entiers en **JavaScript** et en **Rust**.

- [javascript/somme](./javascript/somme.js)
- [rust/somme](./rust/techtalk/src/examples/somme.rs)

Vous remarquerez que dans l'exemple en **Rust**, le type des arguments `a` et `b`, ainsi que le type de retour, noté `-> type` sont précisés. En l'occurrence, il s'agit du type `i32`, c'est-à-dire un nombre entier de taille 32 bits.

*Faisons à nouveau une digression. Il existe une différence fondamentale entre **Rust** et **JavaScript** : **Rust** est un langage de bas niveau tandis que **JavaScript** est un langage de haut niveau. Nous n'entrerons pas non plus dans les détails. Sachez juste qu'en **Rust**, comme en **C++**, le dévelopeur est responsable de la quantité de mémoire allouée à une variable. Il en découle la nécessité d'avoir des nombres entiers de tailles différentes comme `i8`, `i16`, `i32`, ...*

Le fait de préciser le type des arguments et du retour de la fonction restreint son utilisation. Afin d'illustre cela, prenons d'abord le cas de la fonction `somme()` en **JavaScript**. Bien que celle-ci soit prévue pour additionner 2 nombres (entiers), rien ne vous empêche de l'utiliser pour concaténer deux chaines de caractères :

```js
//  JS
somme("une chaine", "de caractère")
```

Sans surprise, afficher le résultat de cette fonctione donne :

```sh
une chaine de caractère
```

En revanche, si nous essayons d'utiliser la fonction `somme()` en **Rust** sur ces deux mêmes chaines de caractères, le compilateur nous renvoit l'erreur suivante :

```sh
error[E0308]: arguments to this function are incorrect
```

Tout ce que nous venons de dire reste valable pour une classe, ses attributs et ses méthodes. Définissons une classe simple, en **C#**, qui possède deux attributs, `name` et `valid` :

```c#
//  C#
class Example
{
    private string name;
    private bool valid;

    //  Constructeur
    public Example(string name, bool valid)
    {
        this.name = name;
        this.valid = valid;
    }
}
```

Lors de la création d'une classe, il est nécessaire de préciser le type de chaque attribut. Dés lors, toute tentative d'instancier la classe `Example` avec des types de `name` et `validity` différents de `string` et `bool` respectivement générera une erreur similaire. Cette contrainte apparait explicitement dans la définition du constructeur.

Parlons enfin des bénéfices de cette approche. Par rapport à un système de typage dynamique comme nous le retrouvons en **JavaScript**, un système de typage statique est indiscutablement plus rigide. En contrepartie de cette rigidité, ce système prévient toute une catégorie d'erreurs que vous avez sans doute déjà rencontré et qui, dans le cas de **JavaScript**, se manifeste par l'apparition de valeurs `undefined` un peu partout dans votre code. Une telle erreur peut arriver quand vous essayez d'utiliser une méthode de l'objet `String` sur un objet de type `Array`, comme la méthode `map()`. Le système de typage statique prévient cette erreur par le biais du compilateur qui, lors de la compilation, connait le type de chaque valeur que vous manipulez à chaque instant, exception faite des valeurs qui ne peuvent être déterminées que pendant l'exécution du programme, comme lorsque vous communiquez avec un serveur.

*Nous avons dit que nous ne parlerons pas de compilateur et d'interpréteur. Toutefois, vous devez comprendre que "prévenir des erreurs" signifie "avant l'exécution du programme". En règle générale, celà est impossible avec un langage interprété comme **JavaScript** puisque la conversion du code en langage compréhensible par la machine se fait en même temps que l'exécution du code. Ce n'est pas le cas d'un langage compilé qui converti d'abord le code en un exécutable. Nous pouvons noter la rare exception qu'est le langage **Raku**.* 

Revenons sur la contrainte qu'impose le système de typage. Lors de la lecture, vous vous êtes peut-être posé la question suivante : **Que devons-nous faire si nous voulons que notre fonction `somme()` accepte des nombres réels (à virgule) ou des chaines de caractères en argument ?** **Devons-vous écrire une autre version de cette fonction pour chaque type ?** A une époque pas si lointaine, c'est effectivement ce qu'il fallait faire. Vous conviendrez que devoir écrire la même fonction chaque cas de figure rend est rébarbatif. Heureusement, pour faire face à ce problème, une technique s'est imposée au début des années 2000 : la programmation générique.

### Programmation générique

Regardons à présent comment résoudre le soucis de la répétition de code dans les systèmes de typage statique à partir de l'exemple de notre fonction `somme()` :

- [dotnet/Somme](./dotnet/techtalk/TechTalk/Somme.cs)
- [dotnet/SommeAvecGenerique](./dotnet/techtalk/TechTalk/SommeAvecGenerique.cs)

*Puisque les fonctions n'existent pas en **C#**, nous simulons la fonction `somme()` avec une méthode statique.*

Le premier exemple consiste a écrire la fonction `somme()` pour différents types numériques (`int`, `double`). Ces implémentations ne sont pas exhaustives mais la nomenclature des méthodes représente bien comment faire du typage statique avant l'arrivée des génériques.

Analysons le second exemple, celui qui nous intéresse. Il y a beaucoup de choses à dire dessus, nous allons donc réécrire la partie qui nous intéresse pour l'analyser :

```c#
//  C#
public static T Somme<T>(T a, T b) where T : INumber<T>
{
    return a + b;
}
```

Dans cet exemple, nous définissons un **type générique** `T`. Vous pouvez interpréter ce générique comme une "variable de type", dont le nom est "T", que vous passez à la méthode `Somme()`. Vous remarquerez que ce `T` prend la place de `int` ou `double` dans le premier exemple. Afin de lever une ambigüité, sachez que nous aurions pu nommer notre générique `cupOfTea` sans que ça n'impacte le résultat. Toutefois, il existe des conventions (propre à un langage) pour nommer un générique en fonction de l'ensemble des types qu'il incarne. Selon ces conventions, nous aurions dû nommer notre générique `N` car il remplace tous les types numériques. Quand aucune convention ne correspond, utilisez simplement `T` pour "Type".

Maintenant, regardons à quoi sert chaque T dans la déclaration de la méthode `Somme()`

```c#
//  C#
public static T Somme<T>(T a, T b) where T : INumber<T>
              1       2  3    4          5           6
```

Le plus important, celui qui correspond à la déclation du générique est le `T` numéro 2. La syntaxe `<T>` signifie que nous déclarons le générique `T` comme argument de la méthode `Somme()` comme, par analogie, nous déclarons les arguments `a` et `b`.
Concernant les `T` numéros 1, 3 et 4, nous avons déjà dit qu'ils jouent le même rôle qu'un type concret comme `int`. 

Avant de parler de la dernière partie de la déclation de notre méthode `Somme()`, prenons le temps de remarquer quelque chose de trivial. Puisque `T` peut incarner, a priori, n'importe quel type, nous pourrions conclure hativement que nous avons inventé le typage dynamique dans un système de typage statique. C'est évidemment faux. Afin d'expliquer pourquoi, ajoutez une ligne de code dans la [méthode `Somme<T>()`](./dotnet/techtalk/TechTalk/SommeAvecGenerique.cs) qui modifie la valeur de `a` par une chaine de caractère, ou même un nombre. Vous obtiendrez l'erreur :

```sh
Cannot implicitly convert type 'string' to 'T'
```

Vous reconnaitrez peut-être l'erreurr que nous avons rencontré dans l'introduction. Le type générique `T` n'est pas définit explicitement mais se comporte comme un type concret. Ainsi, il n'est pas possible de changer le type de `a` et de `b`.

Pour ressentir toute la puissance des types génériques, regardons ce qu'il se passe quand nous [appelons cette méthode](/dotnet/techtalk/TechTalk/Program.cs). En opposition à l'approche sans générique, vous remarquerez qu'on nous utilisons bien la même fonction à 2 reprises. Dans cet exemple, nous exploitons la capacité du compilateur à inférer le type concret de `T`. Si ce n'était pas possible, nous devrions le préciser :

```c#
//  C#
int result1 = SommeAvecGenerique.Somme<int>(2, 3);
double result2 = SommeAvecGenerique.Somme<double>(0.1, 0.2);
```

C'est tout de suite plus verbeux ! Heureusement, l'inférence se fait à deux niveau :

- Lors de la déclaration de `result1` et `result2`. Le type de ces variables est déduit du type concret de la méthode générique `Somme<T>`.
- Lors de l'appel de la méthode `Somme<T>`. Le type concret de `T` est déduit des valeurs passées en arguments de la méthode.

Toutes ces couches d'abstraction simplifient le travail des développeurs.

Du point de vue de l'ordinateur, le compilateur défini une nouvelle méthode `Somme()` pour chaque type concret utilisés dans le programme. Ce procédé s'appelle monomorphization et il nous épargne de devoir écrire une méthode pour chaque cas de figure comme dans le [premier exemple](/dotnet/techtalk/TechTalk/Somme.cs).

Revenons maintenant à la dernière partie de la déclaration de la méthode `Somme<T>()` :

```c#
//  C#
where T : INumber<T>
```

Cette dernière partie sert à restreindre les types concrets que peut prendre le générique `T` à l'ensemble des classes qui implémentent l'interface `INumber`. Si vous n'êtes pas familier des concepts d'interface et d'implémentation, nous reviendrons dessus plus tard. En attendant, voyez une interface comme une classe qui n'aurait que des méthodes vides et une implémentation comme le fait d'hériter des méthodes de cette interface tout en les remplissant.

Une dernière notion importante avec les types génériques est leur encapsulation. Imaginez que vous ayez besoin de construire une classe [`Arithmetic<T>`](/dotnet/techtalk/TechTalk/Arithmetique.cs) pour encapsuler et manipuler des nombres. Plutôt que de créer une classe pour chaque type numérique, vous pouvez définir une classe générique de la même façon que nous l'avons fait avec la méthode `Somme<T>()`. Toutefois, contrairement au cas de la méthode, le compilateur de `C#` n'est pas capable d'inférer le type concret de `T` à partir des valeurs passées dans le constructeur, il faut donc le préciser au moment de l'[instanciation](/dotnet/techtalk/TechTalk/Program.cs). D'autres langages en sont capable. a besoin que vous lui donnez un type concret lors de l'instanciation de la classe `Arithmetic<T>`.

Par soucis de simplicité, nous n'avons traité que des exemples avec un générique. Bien entendu, nous pouvons définir autant de type générique que nous en avons besoin et les mélanger avec des types concrets :

```c#
//  C#
class Example
{
    public static void ExampleMethod<T, U, V>(T arg1, U arg2, V arg3, int arg4, string arg5)
    {
        // code
    }
}
```

Chaque type générique peut être restreint par le mot clef `where`, et ces restrictions peuvent être différentes pour `T`, `U` et `V`. L'implémentation des types génériques varie d'un langage à l'autre. En général, les règles et la syntaxe tendent à se simplifier et offrir plus de confort au développeur avec les langages plus récents. Si le sujet vous intéresse, vous pouvez comparer les implémentations des génériques en **Java** et en **C#**.

Maintenant que nous avons fait le tour du sujet des génériques et expliqué comment ils permettent d'épargner énormément de répétabilité dans le code, posons nous une dernière question. **Comment fait-on si nous avons besoin que le type d'une variable change pendant l'exécution ?** La réponse courte est que vous ne pouvez pas, pas directement. En général, la librarie standard d'un langage intègre des méthodes pour convertir le type de la valeur d'une variable que vous devrez bien entendu stocker dans une autre variables. Par exemple :

```c#
//  C#
int number = 0;
string numberString = number.ToString();
```

Une stratégie qui doit vous sembler familière. Toutefois, cette approche n'est pas possible pour les types définis par le développeur, sachant que chaque classe défini un nouveau type. Une approche commune qui s'intègre bien avec la programmation générique s'appelle **polymorphisme**. Nous exploitons déjà ses propriétés quand nous limitons le type de `T` à l'interface `INumber` dans les exemples précédents.

## Polymorphisme

La notion de polymorphisme ne vous est peut-être pas étrangère si vous avez une certaine expérience en programmation orientée objet puisque ce concept n'est pas exclusif aux langages à système de typage statique. Le polymorphisme peut être défini simplement comme le fait que deux classes partagent une même méthode dont les implémentations diffèrent.

Dans un langage au typage dynamique comme **JavaScript**, le polymorphisme n'a pas vraiment d'application qui lui est propre puisque deux objets peuvent être utilisés de manière indifférenciée, au risque de rencontrer un `undefined`. En revanche, ce concept est fondamental dans les langages orientés objet au typage statique puisqu'il permet simuler un typage dynamique dans une version plus contrôlée.

Pour produire cet effet, deux stratégies sont utilisées : l'**héritage** et la **composition**. Attention, l'héritage et la composition sont des concepts à part entière et ne réduisent pas au polymorphisme. En revanche, ces deux concepts peuvent être utilisés pour faire du polymorphisme.

### Polymorphisme à base d'héritage

Le polymorphisme à base d'héritage est l'exemple que vous trouverez le plus souvent dans la littérature. Pour l'accomplir, nous avons besoin d'une classe générale et d'au moins deux classes spécialisées.

- [dotnet/PolymorphismeAvecHeritage](/dotnet/techtalk/TechTalk/PolymorphismeAvecHeritage.cs)

Nous n'entrerons pas dans les détails de cette implémentation car c'est impossible sans entrer dans les détails du langage. Ce que vous devez remarquer est que les deux classe `Canard` et `Chat` héritent toutes les deux des attributs et des méthodes de la classe `Animal`. Ici, notre classe `Animal` n'a pas de valeur par défaut pour son attribut `species` et n'a pas d'implémentation par défaut pour sa méthode `Noise`, mais ce n'est pas toujours le cas quand vous utilisez du polymorphisme. Par exemple, nous aurions pu créer une classe chien qui possède un cri (Waf !), puis nous aurions pu créer des classes pour chaque race de chien et modifier le cri pour rendre compte du timbre propre à chaque race (Waf !, Wouf !, ...). Dans ce cas, nous pourrions quand même faire aboyer un chien de race inconnue que nous représenterions avec une instance de la classe parent `Chien`.

Dans le présent exemple, nous dirons que le polymorphisme est basé sur l'héritage en ce sens que les classes héritières `Canard` et `Chat` **sont** des `Animal`(-aux) car elles en ont les caractéristiques (attributs) et les comportements (méthodes). Bien entendu, chacune de ces classes héritières peuvent posséder des attributs et des méthodes qui leurs sont propres, comme des ailes, une queue, la capacité de voler ou la capacité de voir dans le l'obscurité.

*A titre d'information, la plus part des langages orienté objet implémentent une structure de donnée moderne appelée "classe abstraite" qui permet de simplifier l'écriture de polymorphisme basée sur l'héritage d'une classe générale qui n'a pas vocation à être instanciée comme dans notre exemple avec la classe `Animal`.*

Après toutes ces explications, vous vous demandez sans doute ce que tout celà à avoir avec le typage statique. Nous y arrivons. Admettons que nous développions une application pour détenteurs d'animaux de compagnie. Rien ne nous dit que les utilisateurs de notre application auront tous exactement un animal de compagnie, nous devons donc implémenter une liste. **Problème : comment créer une liste qui peut accueillir des animaux d'espèces différentes ?** 

Pour résoudre ce problème, nous pouvons nous passer de nos classes `Canard` et `Chat` (et donc du polymorphisme), et donner la responsabilité de différencier chaque espèce d'animal à la classe générale `Animal`. Vous imaginez bien que cette approche est fastidieuse. En procédant ainsi, nous devrions préciser à chaque fois si oui ou non un animal à une queue, si oui ou non il peut voler, ... La quantité d'attributs et de méthodes serait ingérable.

Plutôt que de nous compliquer la vie, [utilisons le système d'héritage à notre avantage](/dotnet/techtalk/TechTalk/Program.cs). Plus tôt dans le texte, nous avons évoqué le fait que chaque classe déclarée par le développeur déclare également un type. Autrement dit, chaque instance de la classe `Animal` est une variable de type `Animal`. Vous vous en doutez, quand une classe hérite d'une autre, elle hérite aussi de son type. En conséquence, les classes `Canard` et `Chat` sont respectivement de type `Canard` et `Chat` **et** de type `Animal`. La réciproque n'est pas vraie (un animal n'est pas un canard). Nous pouvons pousser la logique un cran plus loin et déclarer une variable de type `Animal` pour y assigner des instances de `Canard` et de `Chat` sans que celà ne pose de problème.

Voilà, nous avons reproduit une forme de typage dynamique contrôlé dans un système de typage statique ! Toutefois, nous avons mentionné une autre façon de faire. Nous ne nous attarderons pas sur les raisons historiques qui justifient l'existence d'une seconde approche. Nous nous contenterons d'un simple exemple fictif pour illustrer un problème induit par cette première approche :

```c#
//  C#
var animaux = new List<Animal>();
animaux.Add(new Canard());
animaux.Add(new Chat());
animaux.Add(new Moustique());
foreach (Animal animal in animaux)
{
    animal.cri()
    animal.voler();
}
```

Comme vous le devinez, le code ci-dessus génère une erreur car la classe `Chat` ne possède pas de méthode `voler()`. C'est pour ça que la seconde approche se repose plutôt sur l'idée d'**avoir** des comportements en commun plutôt que d'**être** une entité plus globale. Cependant, avant de nous pencher sur cette seconde approche, explorons un exemple supplémentaire qui va nous permettre de faire le lien avec les génériques :

- [dotnet/PolymorphismeAvecHeritageEtGenerique](/dotnet/techtalk/TechTalk/PolymorphismeAvecHeritageEtGenerique.cs)

Dans cet exemple, nous construisons une méthode statique qui nous permet de faire aboyer un `Chien` indépendamment de sa race (`Golden_Retriever` ou `Rottweiler`), mais nous contraignons le type de l'argument `chien` à l'aide d'un générique :

```c#
//  C#
class Trick
{
    public static void Aboyer<T>(T chien) where T : Chien
    {
        chien.Cri();
    }
}
```

Notez que, dans cet exemple, il serait tout à fait équivalent de définir la méthode `Aboyer<T>()` comme suit :

```c#
public static void Aboyer(Chien chien)
```

Toutefois, vous rencontrerez des situations où du polymorphisme avec et sans générique ne sont pas interchangeables.

### Polymorphisme à base de composition

La seconde stratégie pour mettre en place du polymorphisme repose sur l'idée de composer une entité concrète à partir de comportements. Afin de rendre cette approche plus simple, la majorité des langages de programmation orientée objet implémente une structure appelée **interface** (parfois trait).

Une interface diffère d'une classe (abstraite ou non) sur deux deux points :

- Elle ne possède que des méthodes, aucun attribut.
- Aucune des méthodes d'une interface ne possède d'implémentation par défaut, elles sont toutes vides.

Par essence, les interfaces s'inscrivent sans difficulté dans le paragidme de composition bien qu'elle s'intègrent également dans le paradigme d'héritage. Toutefois, la composition ne se cantonne pas au polymorphisme. Dans la plus part des langages, seul un mot clef distingue le procédé qui consiste à transférer le contenu d'une classe/interface vers une autre classe, quand ce mot clef n'est pas carrément le même comme en **C#** (mot clef qui consiste en `:`). 

Regardons comme construire notre exemple d'animaux avec des interfaces :

- [dotnet/PolymorphismeAvecComposition](/dotnet/techtalk/TechTalk/PolymorphismeAvecComposition.cs)

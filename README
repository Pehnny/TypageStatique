# Langages de programmation au typage statique

- [Introduction](#introduction)
- [Typage statique](#typage-statique)
    - [Fonctions et classes](#fonctions-et-classes)
    - [Programmation générique](#programmation-générique)
    - [Duck Typing]()
        - [Héritage]()
        - [Polymorphisme]()
    - [TypeScript]()
- [Conclusion]()

## Introduction

Ce repo s'addresse aux développeurs qui n'ont connu que des langages au typage dynamique. Ici, nous nous intéresserons à **JavaScript**, mais il n'est pas le seul langage populaire à présenter cette caractéristique. Un exemple notable est **Python**. 

La spécificité d'un langage au typage dynamique est que le type d'une variable peut changer à n'importe quel moment. Ce concept peut vous paraître abstrait puisque, du point de vue d'un développeur **JavaScript**, le concept de type n'existe pas. Pour vous aider à comprendre de quoi il retourne, regardons comment une variable est déclarée dans des langages au typage dynamique et statique en commençant par **JavaScript** :

```js
//  JS
let variable = 1;
variable = "text";
```

Si nous affichions la valeur de `variable` dans le terminal, nous lirions :

```sh
text
```

En opposition, regardons le même code en **C#** :

```c#
//  C#
int variable = 1;
variable = "text";
```

Vous pouvez constater que la déclaration de `variable` contient le mot clef `int` plutôt que `let`. Celà signifie que `variable` est une variable qui ne peut contenir que des valeurs de type `int` (nombre entier). Si nous essayions d'afficher la valeur de `variable` comme à l'exemple précédent, nous n'y arriverions pas car le code ne compilarai pas :

```sh
error CS0029: Impossible de convertir implicitement le type 'string' en 'int'
```

*Faisons une brève digression pour souligner que **JavaScript** et **C#** ont une autre différence majeure que leur système de type : **JavaScript** est un langage interprêté tandis que **C#** est un langage compilé. Cette autre différence fondamentale a des implications tout aussi importante que le système de typage mais nous n'avons pas l'espace pour explorer le sujet ici !*

La syntaxe `type <name>` est considérée comme désuète aujourd'hui. Elle se retrouve principalement sur des langages qui ont au moins 20 ans comme **C++**, **C#** ou **Java**. Les langages modernes comme **Kotlin** et **Rust** utilisent une syntaxe de la forme `keyword <name> : type` :

```rust
//  Rust
let variable : i32 = 1;
```

Voilà une syntaxe qui ne vous bousculera pas trop de vos habitudes en **JavaScript** ! Histoire de vous éviter un peu plus le mal du pays, il se trouve que ces langages ont la capacité d'inférer le type d'une variable selon le contexte de son allocation. Dit plus simplement, il n'est pas toujours (ça dépend du contexte) nécessaire de préciser le type de la variable :

```rust
//  Rust
let variable = 1;
```

Cette approche semble tellement évidente que les plus vieux langages comme **C#** et **Java** ont également adopté cette syntaxe à un moment donné de leur histoire. En l'occurrence, les deux langages cités ont opté pour le mot clef `var`. Malheureusement, quand il n'est pas possible d'inférer le type d'une variable, il faut revenir à la vieille syntaxe, syntaxe qui est quand même moins élégante, vous me l'accorderez !

A ce stade, vous ne voyez sans doute pas l'intérêt du système de typage, c'est normal. C'est pour ça que nous allons explorer plus d'exemples afin de parler des bénéfices de ce système.

## Typage statique

Dans l'[introduction](#introduction), nous avons vu comment un système de typage statique impact la déclaration et l'allocation de variables. Toutefois, cet exemple est trop basique pour que nous puissions parler des avantages et des inconvénients d'un tel système.

Afin d'explorer les bienfaits du typage statique, penchons nous d'abord sur la construction de fonctions et de classes.

### Fonctions et classes

Commençons par regarder comment construire une fonction qui additionne 2 nombres entiers en **JavaScript** et en **Rust**.

- [javascript/somme](./javascript/somme.js)
- [rust/somme](./rust/techtalk/src/examples/somme.rs)

Vous remarquerez que dans l'exemple en **Rust**, le type des arguments `a` et `b`, ainsi que le type de retour, noté `-> type` sont précisés. En l'occurrence, il s'agit du type `i32`, c'est-à-dire un nombre entier de taille 32 bits.

*Faisons à nouveau une digression. Il existe une différence fondamentale entre **Rust** et **JavaScript** : **Rust** est un langage de bas niveau tandis que **JavaScript** est un langage de haut niveau. Nous n'entrerons pas non plus dans les détails. Sachez juste qu'en **Rust**, comme en **C++**, le dévelopeur est responsable de la quantité de mémoire allouée à une variable. Il en découle la nécessité d'avoir des nombres entiers de tailles différentes comme `i8`, `i16`, `i32`, ...*

Le fait de préciser le type des arguments et du retour de la fonction restreint son utilisation. Afin d'illustre cela, prenons d'abord le cas de la fonction `somme()` en **JavaScript**. Bien que celle-ci soit prévue pour additionner 2 nombres (entiers), rien ne vous empêche de l'utiliser pour concaténer deux chaines de caractères :

```js
//  JS
somme("une chaine", "de caractère")
```

Sans surprise, afficher le résultat de cette fonctione donne :

```sh
une chaine de caractère
```

En revanche, si nous essayons d'utiliser la fonction `somme()` en **Rust** sur ces deux mêmes chaines de caractères, le compilateur nous renvoit l'erreur suivante :

```sh
error[E0308]: arguments to this function are incorrect
```

Tout ce que nous venons de dire reste valable pour une classe, ses attributs et ses méthodes. Définissons une classe simple, en **C#**, qui possède deux attributs, `name` et `valid` :

```c#
//  C#
class Example
{
    private string name;
    private bool valid;

    //  Constructeur
    public Example(string name, bool valid)
    {
        this.name = name;
        this.valid = valid;
    }
}
```

Lors de la création d'une classe, il est nécessaire de préciser le type de chaque attribut. Dés lors, toute tentative d'instancier la classe `Example` avec des types de `name` et `validity` différents de `string` et `bool` respectivement générera une erreur similaire. Cette contrainte apparait explicitement dans la définition du constructeur.

Parlons enfin des bénéfices de cette approche. Par rapport à un système de typage dynamique comme nous le retrouvons en **JavaScript**, un système de typage statique est indiscutablement plus rigide. En contrepartie de cette rigidité, ce système prévient toute une catégorie d'erreurs que vous avez sans doute déjà rencontré et qui, dans le cas de **JavaScript**, se manifeste par l'apparition de valeurs `undefined` un peu partout dans votre code. Une telle erreur peut arriver quand vous essayez d'utiliser une méthode de l'objet `String` sur un objet de type `Array`, comme la méthode `map()`. Le système de typage statique prévient cette erreur par le biais du compilateur qui, lors de la compilation, connait le type de chaque valeur que vous manipulez à chaque instant, exception faite des valeurs qui ne peuvent être déterminées que pendant l'exécution du programme, comme lorsque vous communiquez avec un serveur.

*Nous avons dit que nous ne parlerons pas de compilateur et d'interpréteur. Toutefois, vous devez comprendre que "prévenir des erreurs" signifie "avant l'exécution du programme". En règle générale, celà est impossible avec un langage interprété comme **JavaScript** puisque la conversion du code en langage compréhensible par la machine se fait en même temps que l'exécution du code. Ce n'est pas le cas d'un langage compilé qui converti d'abord le code en un exécutable. Nous pouvons noter la rare exception qu'est le langage **Raku**.* 

Revenons sur la contrainte qu'impose le système de typage. Lors de la lecture, vous vous êtes peut-être posé la question suivante : **Que devons-nous faire si nous voulons que notre fonction `somme()` accepte des nombres réels (à virgule) ou des chaines de caractères en argument ?** **Devons-vous écrire une autre version de cette fonction pour chaque type ?** A une époque pas si lointaine, c'est effectivement ce qu'il fallait faire. Vous conviendrez que devoir écrire la même fonction chaque cas de figure rend est rébarbatif. Heureusement, pour faire face à ce problème, une technique s'est imposée au début des années 2000 : la programmation générique.

### Programmation générique

Regardons à présent comment résoudre le soucis de la répétition de code dans les systèmes de typage statique à partir de l'exemple de notre fonction `somme()` :

- [dotnet/Somme](./dotnet/techtalk/TechTalk/Somme.cs)
- [dotnet/SommeAvecGenerique](./dotnet/techtalk/TechTalk/SommeAvecGenerique.cs)

*Puisque les fonctions n'existent pas en **C#**, nous simulons la fonction `somme()` avec une méthode statique.*

Le premier exemple consiste a écrire la fonction `somme()` pour différents types numériques (`int`, `double`). Ces implémentations ne sont pas exhaustives mais la nomenclature des méthodes représente bien comment faire du typage statique avant l'arrivée des génériques.

Analysons le second exemple, celui qui nous intéresse. Il y a beaucoup de choses à dire dessus, nous allons donc réécrire la partie qui nous intéresse pour l'analyser :

```c#
public static T Somme<T>(T a, T b) where T : INumber<T>
{
    return a + b;
}
```

Dans cet exemple, nous définissons un **type générique** `T`. Vous pouvez interpréter ce générique comme une "variable de type", dont le nom est "T", que vous passez à la méthode `Somme()`. Vous remarquerez que ce `T` prend la place de `int` ou `double` dans le premier exemple. Afin de lever une ambigüité, sachez que nous aurions pu nommer notre générique `cupOfTea` sans que ça n'impacte le résultat. Toutefois, il existe des conventions (propre à un langage) pour nommer un générique en fonction de l'ensemble des types qu'il incarne. Selon ces conventions, nous aurions dû nommer notre générique `N` car il remplace tous les types numériques. Quand aucune convention ne correspond, utilisez simplement `T` pour "Type".

Maintenant, regardons à quoi sert chaque T dans la déclaration de la méthode `Somme()`

```c#
public static T Somme<T>(T a, T b) where T : INumber<T>
              1       2  3    4          5           6
```

Le plus important, celui qui correspond à la déclation du générique est le `T` numéro 2. La syntaxe `<T>` signifie que nous déclarons le générique `T` comme argument de la méthode `Somme()` comme, par analogie, nous déclarons les arguments `a` et `b`.
Concernant les `T` numéros 1, 3 et 4, nous avons déjà dit qu'ils jouent le même rôle qu'un type concret comme `int`. 

Avant de parler de la dernière partie de la déclation de notre méthode `Somme()`, prenons le temps de remarquer quelque chose de trivial. Puisque `T` peut incarner, a priori, n'importe quel type, nous pourrions conclure hativement que nous avons inventé le typage dynamique dans un système de typage statique. C'est évidemment faux. Afin d'expliquer pourquoi, ajoutez une ligne de code dans la [méthode `Somme<T>()`](./dotnet/techtalk/TechTalk/SommeAvecGenerique.cs) qui modifie la valeur de `a` par une chaine de caractère, ou même un nombre. Vous obtiendrez l'erreur :

```sh
Cannot implicitly convert type 'string' to 'T'
```

Vous reconnaitrez peut-être l'erreurr que nous avons rencontré dans l'introduction. Le type générique `T` n'est pas définit explicitement mais se comporte comme un type concret. Ainsi, il n'est pas possible de changer le type de `a` et de `b`.

Pour ressentir toute la puissance des types génériques, regardons ce qu'il se passe quand nous [appelons cette méthode](/dotnet/techtalk/TechTalk/Program.cs). En opposition à l'approche sans générique, vous remarquerez qu'on nous utilisons bien la même fonction à 2 reprises. Dans cet exemple, nous exploitons la capacité du compilateur à inférer le type concret de `T`. Si ce n'était pas possible, nous devrions le préciser :

```c#
int result1 = SommeAvecGenerique.Somme<int>(2, 3);
double result2 = SommeAvecGenerique.Somme<double>(0.1, 0.2);
```

C'est tout de suite plus verbeux ! Heureusement, l'inférence se fait à deux niveau :

- Lors de la déclaration de `result1` et `result2`. Le type de ces variables est déduit du type concret de la méthode générique `Somme<T>`.
- Lors de l'appel de la méthode `Somme<T>`. Le type concret de `T` est déduit des valeurs passées en arguments de la méthode.

Toutes ces couches d'abstraction simplifient le travail des développeurs.

Du point de vue de l'ordinateur, le compilateur défini une nouvelle méthode `Somme()` pour chaque type concret utilisés dans le programme. Ce procédé s'appelle monomorphization et il nous épargne de devoir écrire une méthode pour chaque cas de figure comme dans le [premier exemple](/dotnet/techtalk/TechTalk/Somme.cs).

Revenons maintenant à la dernière partie de la déclaration de la méthode `Somme<T>()` :

```c#
where T : INumber<T>
```

Cette dernière partie sert à restreindre les types concrets que peut prendre le générique `T` à l'ensemble des classes qui implémentent l'interface `INumber`. Si vous n'êtes pas familier les concepts d'interface et d'implémentation, voyez l'interface comme une classe qui n'aurait que des méthodes sans implémentation (vide) et l'implémentation comme le fait d'hériter et de cette interface, et de l'implémenter :

```c#
//  C#
interface IExample
{
    public string ExampleMethod();
}
class Example : IExample
{
    public string ExampleMethod()
    {
        return "example";
    }
}
```

Une dernière notion importante avec les types génériques est leur encapsulation. Imaginez que vous ayez besoin de construire [une classe](/dotnet/techtalk/TechTalk/Arithmetic.cs) pour encapsuler et manipuler des nombres. Plutôt que de créer une classe pour chaque type numérique, vous pouvez définir une classe générique de la même façon que nous l'avons fait avec la méthode `Somme<T>()`. Dans ce cas, vous constaterez que `C#` a besoin que vous lui donniez un type concret lors de l'instanciation de la classe `Arithmetic<T>`. Une fois que nous avons créé notre instance, le type de `T` est clairement défini pour tous les attributs et toutes les méthodes de cette instance.
